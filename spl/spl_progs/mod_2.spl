alias funcNum R1;
alias currPID R2;

if(funcNum == 1) then
	//Increment WAIT_MEM_COUNT
	[SYSTEM_STATUS_TABLE + 3] = [SYSTEM_STATUS_TABLE + 3] + 1;
	while([SYSTEM_STATUS_TABLE + 3]==0) do
		[PROCESS_TABLE + (currPID * 16) + 4] = WAIT_MEM;
		multipush(R1,R2);
		call MOD_5;
		multipop(R1,R2);
	endwhile;
	//Decrement the WAIT_MEM_COUNT and MEM_FREE_COUNT 
	[SYSTEM_STATUS_TABLE + 3] = [SYSTEM_STATUS_TABLE + 3] - 1;
	[SYSTEM_STATUS_TABLE + 2] = [SYSTEM_STATUS_TABLE + 2] - 1;
	alias freeCounter R3;
	freeCounter = 76;
	while (freeCounter< MAX_MEM_PAGE) do
			if([MEMORY_FREE_LIST + freeCounter] == 0) then
					[MEMORY_FREE_LIST + freeCounter] = 1;
					R0 = freeCounter;
					return;
			endif;
			freeCounter = freeCounter+1;
	endwhile;
	breakpoint;
	return;
endif;

if(funcNum == 2) then
	alias page R2;
	[MEMORY_FREE_LIST + page] = [MEMORY_FREE_LIST + page] - 1;
	if([MEMORY_FREE_LIST + page] == 0) then
		[SYSTEM_STATUS_TABLE + 2] = [SYSTEM_STATUS_TABLE + 2] + 1;
	endif;
	alias pidCounter R3;
    pidCounter = 1;
    while (pidCounter < 16) do
        if ([PROCESS_TABLE + 16*pidCounter + 4 ] == WAIT_MEM) then
            [PROCESS_TABLE + 16*pidCounter + 4 ] = READY;
        endif;
        pidCounter = pidCounter + 1;
    endwhile;
		breakpoint;
	return;
endif;